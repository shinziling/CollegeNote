
> [!note] Bytes and Bits
> 1 bit of data is $2^0$ which can holds either 0 or 1.
> - There are 8 bits in a byte.



Data types in C is separated into three categories: Integral, floating, and pointer


| Bytes | Integral Types | Range                    |
| ----- | -------------- | ------------------------ |
| 1     | char           | -128 to 127              |
| 2     | short          | -32768 to 32767          |
| 4     | int            | $-2^{31}$ to $2^{31} -1$ |
| 8     | long           | $-2^{63}$ to $2^{63} -1$ |

| Bytes | Floating types | Range        |
| ----- | -------------- | ------------ |
| 4     | float          | $\pm 2^{31}$ |
| 8     | double         | $\pm 2^{63}$ |


| Bytes | Pointer type | Range                                                           |
| ----- | ------------ | --------------------------------------------------------------- |
| 4/8   | pointer      | can be either 32 bits or 64 bits <br>                           |
|       | array        | points to a fixed location such as `int [] or double [][]` etc. |

> Integral types has 1 extra number in its negative range than positive; this has to do with something called the Two's Complement representation. Meanwhile, floating types are symmetrical across its negative and positive range. 


## Missing Types

- Booleans are not used in C. Any piece of data in C is either true or false. Typically, 0 is the only thing that is false. With that being said any data that has a 1 in it is true. So, 001000 is true else if it is all 0's then it is false. 
- String. There is no dedicated type for string in C. Strings are just an array of characters in C. Languages like Java has a dedicated String class that has some useful implementations such as `substring()` and `indexOf()`.



# Void Pointers

Denoted as `void *pointer`, these are pointers that can point to any data type. 
- They can store any memory address but have no ways of retrieving their content (dereferencing) without tricking the compiler to do so.
- They are useful in storing arbitrary memory address
- To dereference, you would do a typecast.

Code ex:
```c
#include <stdio.h> 

int main(){ 

int a = 10;
void *p = &a; // void pointer points to int a address

int b = *((int *) p); // typecast to trick the compiler into dereferencing
printf("%d\n", b); 

return 0;
}
```

Output:
```bash
10
```


